name: Check Broken Links
env:
  test_mode: false
  create_issues: true
  broken_links: false

on:
  schedule:
    - cron: '0 3 * * 1'  # Runs every Monday at 03:00 UTC
  workflow_dispatch:  # Allows manual triggering
    inputs:
      testMode:
        type: boolean
        description: Test mode? (does not create issues)
        default: true
      createIssues:
        type: boolean
        description: Create issues for broken links?
        default: false

jobs:
  check-links:
    name: Check for Broken Links
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check run mode
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          test_mode_val="${{ github.event.inputs.testMode }}"
          create_issues_val="${{ github.event.inputs.createIssues }}"

          # Ensure values are properly set as booleans
          if [[ "$test_mode_val" == "true" ]]; then
            echo "test_mode=true" >> $GITHUB_ENV
          else
            echo "test_mode=false" >> $GITHUB_ENV
          fi

          if [[ "$create_issues_val" == "true" ]]; then
            echo "create_issues=true" >> $GITHUB_ENV
          else
            echo "create_issues=false" >> $GITHUB_ENV
          fi

      - name: Restore lychee cache
        id: restore-cache
        uses: actions/cache/restore@v4
        with:
          path: .lycheecache
          key: cache-lychee-${{ github.sha }}
          restore-keys: cache-lychee-

      - name: Run Lychee to Check Links
        id: lychee
        uses: lycheeverse/lychee-action@v2.2.0
        with:
          args: "--cache --max-cache-age 1d --cache-exclude-status '429, 500..502' --quiet --no-progress --exclude whatdotheyknow.com $(find lib/views -name '*.erb')"
          output: lychee_report.json
          format: json
          fail: false  # Ensure the workflow continues even if broken links are found

      - name: Process Lychee Output
        run: |
          if [ -s lychee_report.json ] && [ "$(jq -r '.error_map' lychee_report.json)" != "{}" ]; then
            jq -r '.error_map | to_entries | map({file: .key, url: .value[].url, status: .value[].status}) | group_by(.url) | map({url: .[0].url, status: .[0].status, files: (map(.file) | unique)}) | .[]' lychee_report.json | jq -s . > reformatted_broken_links.json
          else
            echo "No broken links found or lychee_report.json is empty."
            echo "[]" > reformatted_broken_links.json  # Ensure an empty JSON array is created
          fi
      
          if [ -s reformatted_broken_links.json ] && [ "$(jq 'length' reformatted_broken_links.json)" -gt 0 ]; then
            echo "broken_links=true" >> $GITHUB_ENV
          else
            echo "broken_links=false" >> $GITHUB_ENV
          fi

      - name: Archive raw output
        uses: actions/upload-artifact@v4
        if: ${{ env.test_mode == 'true' }}
        with:
          name: raw-output
          path: |
            lychee_report.json
            reformatted_broken_links.json
          if-no-files-found: warn

      - name: Save lychee cache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: .lycheecache
          key: ${{ steps.restore-cache.outputs.cache-primary-key }}

      - name: Create (or update) Issues for Each Unique Broken Link
        if: ${{ (env.test_mode == 'false' && env.create_issues == 'true' && env.broken_links == 'true') || (env.test_mode == 'true' && env.create_issues == 'true' && env.broken_links == 'true') }}
        run: |
          max_test_issues=1  # Adjust this if we want to allow more issues in test mode
          issue_count=0

          # Ensure file exists and is not empty
          if [[ ! -s reformatted_broken_links.json ]]; then
            echo "Error: reformatted_broken_links.json is empty or missing!"
            exit 1
          fi
          
          # Validate JSON format
          if ! jq empty reformatted_broken_links.json 2>/dev/null; then
            echo "Error: reformatted_broken_links.json contains invalid JSON!"
            exit 1
          fi
              
          # Start processing broken links
          while read -r line; do
            url=$(echo "$line" | jq -r '.url')
            status_code=$(echo "$line" | jq -r '.status.code // "Unknown"')
            status_text=$(echo "$line" | jq -r '.status.text // "Unknown"')
            affected_files=$(echo "$line" | jq -r '.files | join(", ")')
          
            # Check if URL is valid
            if [[ -z "$url" || "$url" == "null" ]]; then
              echo "Skipping invalid entry: $line"
              continue
            fi  
          
            # Define issue title
            issue_title="Broken Link: $url"
          
            # Search for an existing issue with the same URL
            existing_issue=$(gh issue list --state open --label "broken link" --json number,title \
              | jq -r --arg title "$issue_title" '.[] | select(.title == $title) | .number')
          
            # Assign labels (add "help-pages" if needed)
            labels="broken link, non-developer"
            if echo "$affected_files" | grep -q "lib/views/help/"; then
              labels="broken link, non-developer, help-pages"
            fi
          
            # Create issue body
            echo "**Broken Link:** [$url]($url)" > issue.md
            echo "" >> issue.md
            echo "**Status Code:** $status_code ($status_text)" >> issue.md
            echo "**Affected Files:** $affected_files" >> issue.md
          
            if [[ -n "$existing_issue" ]]; then
              echo "Issue already exists (#$existing_issue). Adding a comment..."
              
              # Add a comment to the existing issue
              gh issue comment "$existing_issue" --body "ðŸ”„ **Update:** Broken link still exists. See affected files:\n\n$affected_files"
            
            else
              echo "Creating new issue for $url"
          
              # Create a new issue with proper labels
              gh issue create \
                --title "$issue_title" \
                --body-file issue.md \
                --label "$labels"
            fi
          
            # Increment the counter
            ((issue_count++))
          
            # Stop processing if test mode is enabled and max issues reached
            if [[ "$test_mode" == "true" && "$issue_count" -ge "$max_test_issues" ]]; then
              echo "Test mode active. Stopping after processing $issue_count issue(s)."
              break
            fi
          done < reformatted_broken_links.json
          
