name: Check Broken Links
env:
  test_mode: false
  create_issues: true
  broken_links: false

on:
  schedule:
    - cron: '0 3 * * 1'  # Runs every Monday at 03:00 UTC
  workflow_dispatch:  # Allows manual triggering
    inputs:
      testMode:
        type: boolean
        description: Test mode? (does not create issues)
        default: true
      createIssues:
        type: boolean
        description: Create issues for broken links?
        default: false

jobs:
  check-links:
    name: Check for Broken Links
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check run mode
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          test_mode_val="${{ github.event.inputs.testMode }}"
          create_issues_val="${{ github.event.inputs.createIssues }}"

          # Ensure values are properly set as booleans
          if [[ "$test_mode_val" == "true" ]]; then
            echo "test_mode=true" >> $GITHUB_ENV
          else
            echo "test_mode=false" >> $GITHUB_ENV
          fi

          if [[ "$create_issues_val" == "true" ]]; then
            echo "create_issues=true" >> $GITHUB_ENV
          else
            echo "create_issues=false" >> $GITHUB_ENV
          fi

      - name: Restore lychee cache
        id: restore-cache
        uses: actions/cache/restore@v4
        with:
          path: .lycheecache
          key: cache-lychee-${{ github.sha }}
          restore-keys: cache-lychee-

      - name: Run Lychee to Check Links
        id: lychee
        uses: lycheeverse/lychee-action@v2.2.0
        with:
          args: "--cache --max-cache-age 1d --cache-exclude-status '429, 500..502' --quiet --no-progress --exclude whatdotheyknow.com $(find lib/views -name '*.erb')"
          output: lychee_report.json
          format: json
          fail: false  # Ensure the workflow continues even if broken links are found

      - name: Process Lychee Output
        run: |
          if [ -s lychee_report.json ] && [ "$(jq -r '.error_map' lychee_report.json)" != "{}" ]; then
            jq -r '
              .error_map | to_entries |
              map({file: .key, url: .value[].url, status: .value[].status}) |
              group_by(.url) | map({url: .[0].url, status: .[0].status, files: (map(.file) | unique)}) | .[]' \ 
              lychee_report.json | jq -s . > reformatted_broken_links.json
          else
            echo "No broken links found or lychee_report.json is empty."
            echo "[]" > reformatted_broken_links.json  # Ensure an empty JSON array is created
          fi
      
          if [ -s reformatted_broken_links.json ] && [ "$(jq 'length' reformatted_broken_links.json)" -gt 0 ]; then
            echo "broken_links=true" >> $GITHUB_ENV
          else
            echo "broken_links=false" >> $GITHUB_ENV
          fi

      - name: Archive raw output
        uses: actions/upload-artifact@v4
        if: ${{ env.test_mode == 'true' }}
        with:
          name: raw-output
          path: |
            lychee_report.json
            reformatted_broken_links.json
          if-no-files-found: warn

      - name: Save lychee cache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: .lycheecache
          key: ${{ steps.restore-cache.outputs.cache-primary-key }}

      - name: Create Issues for Each Unique Broken Link (if not already open)
        if: ${{ (env.test_mode == 'false' && env.create_issues == 'true' && env.broken_links == 'true') || (env.test_mode == 'true' && env.create_issues == 'true' && env.broken_links == 'true') }}
        run: |
          jq -c '.[]' reformatted_broken_links.json | while read -r link; do
          url=$(echo "$link" | jq -r '.url')
          status_code=$(echo "$link" | jq -r '.status | .code')
          status_text=$(echo "$link" | jq -r '.status | .text')
          affected_files=$(echo "$link" | jq -r '.files | join(", ")')
        
          echo "Processing $url (Status: $status_code $status_text) in files: $affected_files"
        
          existing_issue=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/issues?state=open&labels=broken%20link" | \
          jq -r '.[] | select(.title | contains("'"$url"'")) | .title')
        
          if [[ ! -z "$existing_issue" ]]; then
            echo "Issue already exists for $url. Skipping..."
            continue
          fi
        
          if echo "$affected_files" | grep -q "lib/views/help/"; then
            labels="broken link, non-developer, help-pages"
          else
            labels="broken link, non-developer"
          fi  
        
          curl -X POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               https://api.github.com/repos/${{ github.repository }}/issues \
               -d '{
             "title": "Broken Link: '"$url"'",
             "body": "The following `.erb` files contain a broken link to **'"$url"'**:\n\n'"$affected_files"'\n\nError: '"$status_code"' '"$status_text"'",
             "labels": ['"$labels"']
               }'
        
          if [[ "$env.test_mode" == "true" ]]; then
            break
          fi
          done
